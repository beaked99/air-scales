{# templates/dashboard/index.html.twig #}
{% extends 'base.html.twig' %}

{% block title %}Dashboard{% endblock %}

{% block body %}
<div class="min-h-screen p-6 text-gray-100 bg-gray-900">
  <h1 class="mb-6 text-2xl font-bold text-green-400">Air Scales Dashboard</h1>

  <!-- Status Bar -->
  <div id="status-bar" class="p-3 mb-6 bg-gray-700 rounded">
    <span id="status-text">Loading...</span>
  </div>

  <!-- Live Sensor Data -->
  <div class="mb-8 overflow-hidden bg-gray-800 rounded-lg">
    <table id="sensor-table" class="w-full text-sm">
      <thead class="bg-gray-700">
        <tr>
          <th class="p-3 text-left text-gray-200">Device</th>
          <th class="p-3 text-right text-gray-200">Weight (lbs)</th>
          <th class="p-3 text-right text-gray-200">Pressure (psi)</th>
          <th class="p-3 text-right text-gray-200">Temp (°F)</th>
          <th class="p-3 text-left text-gray-200">Status</th>
        </tr>
      </thead>
      <tbody id="sensor-data">
        <tr>
          <td colspan="5" class="p-6 text-center text-gray-400">📡 Connecting to devices...</td>
        </tr>
      </tbody>
      <tfoot class="bg-gray-700">
        <tr>
          <td class="p-3 font-bold text-gray-100">TOTAL</td>
          <td id="total-weight" class="p-3 font-bold text-right text-green-400">0.0 lbs</td>
          <td colspan="3" class="p-3 text-gray-400">
            <span id="device-count">0</span> devices
          </td>
        </tr>
      </tfoot>
    </table>
  </div>

  <!-- Connected Devices from Database -->
  <div class="mb-8">
    <h2 class="mb-4 text-xl font-semibold text-white">Your Devices</h2>
    {% if devices is not empty %}
      <div class="bg-gray-800 divide-y divide-gray-700 rounded-lg">
        {% for device in devices %}
          <div class="flex items-center justify-between p-4">
            <div class="flex-1">
              <div class="flex items-center space-x-4">
                <div>
                  <span class="font-medium text-gray-100">{{ device.serialNumber ?: 'Device #' ~ device.id }}</span>
                  <span class="ml-2 text-sm text-gray-400">({{ device.deviceType ?: 'Unknown Type' }})</span>
                </div>
                <div class="text-sm text-gray-300">
                  {% if device.vehicle %}
                    <span class="text-blue-400">{{ device.vehicle }}</span>
                  {% else %}
                    <span class="text-yellow-400">Unassigned</span>
                  {% endif %}
                </div>
              </div>
              <div class="mt-1 text-xs text-gray-500">
                MAC: {{ device.macAddress ?: 'N/A' }} | 
                Firmware: {{ device.firmwareVersion ?: 'Unknown' }}
                {% set hasAccess = false %}
                {% for access in accessRecords %}
                  {% if access.device.id == device.id %}
                    | <span class="text-green-400">Connected via ESP32</span>
                    {% set hasAccess = true %}
                  {% endif %}
                {% endfor %}
                {% if device.soldTo == app.user and not hasAccess %}
                  | <span class="text-blue-400">Purchased</span>
                {% endif %}
              </div>
            </div>
            <div class="flex space-x-2">
              {% if not device.vehicle %}
                <a href="{{ path('device_configure', { id: device.id }) }}" 
                   class="px-3 py-1 text-sm font-medium text-green-400 bg-green-900 rounded hover:text-green-200">
                  Configure
                </a>
              {% endif %}
              <a href="{{ path('device_calibration', { id: device.id }) }}" 
                 class="px-3 py-1 text-sm font-medium text-purple-400 bg-purple-900 rounded hover:text-purple-200">
                Calibrate
              </a>
              {% set userHasAccess = false %}
              {% for access in accessRecords %}
                {% if access.device.id == device.id %}
                  {% set userHasAccess = true %}
                  <a href="{{ path('unlink_device', { id: device.id }) }}" 
                     class="px-3 py-1 text-sm font-medium text-red-400 bg-red-900 rounded hover:text-red-200">
                    Unlink
                  </a>
                {% endif %}
              {% endfor %}
              {% if not userHasAccess %}
                <button onclick="connectToDevice('{{ device.macAddress }}')" 
                        class="px-3 py-1 text-sm font-medium text-blue-400 bg-blue-900 rounded hover:text-blue-200">
                  Connect
                </button>
              {% endif %}
            </div>
          </div>
        {% endfor %}
      </div>
    {% else %}
      <div class="p-6 text-center bg-gray-800 rounded-lg">
        <p class="mb-4 text-gray-400">No devices found.</p>
        <p class="text-sm text-gray-500">Connect to an ESP32 device to get started, or contact support for device registration.</p>
      </div>
    {% endif %}
  </div>

  <!-- Vehicle List -->
  <div id="vehicle-section">
    <h2 class="mb-4 text-xl font-semibold text-white">Your Vehicles</h2>
    {% if vehicles is not empty %}
      <div class="bg-gray-800 divide-y divide-gray-700 rounded-lg" id="vehicle-list">
        {% for vehicle in vehicles %}
          <div class="flex items-center justify-between p-4" data-vehicle-id="{{ vehicle.id }}">
            <div class="flex-1">
              <div class="flex items-center space-x-4">
                <span class="font-medium text-gray-100">{{ vehicle }}</span>
                <span class="text-sm text-gray-400">({{ vehicle.nickname ?: 'No nickname' }})</span>
                {% if connectedMap[vehicle.id] is defined and connectedMap[vehicle.id] %}
                  <span class="px-2 py-1 text-xs text-green-400 bg-green-900 rounded">Connected</span>
                {% endif %}
                {% if vehicle.createdBy != app.user %}
                  <span class="px-2 py-1 text-xs text-orange-400 bg-orange-900 rounded">Shared</span>
                {% endif %}
              </div>
              <div class="mt-1 text-xs text-gray-500">
                {{ vehicle.devices|length }} device(s) assigned
                {% if vehicle.lastSeen %}
                  | Last seen: {{ vehicle.lastSeen|date('M j, Y g:i A') }}
                {% endif %}
                {% if vehicle.createdBy != app.user %}
                  | Owner: {{ vehicle.createdBy ? vehicle.createdBy.fullName : 'Unknown' }}
                {% endif %}
                {% if vehicle.devices|length > 0 %}
                  | <a href="{{ path('device_calibration_history', { id: vehicle.devices[0].id }) }}" class="text-purple-400 hover:text-purple-200">View Calibrations</a>
                {% endif %}
              </div>
            </div>
            <div class="flex space-x-2">
              {% if vehicle.createdBy == app.user %}
                <a href="{{ path('device_vehicle_edit', { id: vehicle.id }) }}"
                   class="px-3 py-1 text-sm font-medium text-blue-400 bg-blue-900 rounded hover:text-blue-200">
                  Manage
                </a>
              {% else %}
                <span class="px-3 py-1 text-sm text-gray-400 bg-gray-700 rounded">
                  View Only
                </span>
              {% endif %}
              <span class="px-2 text-gray-400 cursor-move drag-handle hover:text-gray-200">⋮⋮</span>
            </div>
          </div>
        {% endfor %}
      </div>
    {% else %}
      <div class="p-6 text-center bg-gray-800 rounded-lg">
        <p class="mb-4 text-gray-400">No vehicles found.</p>
        <p class="text-sm text-gray-500">Configure a device to create your first vehicle, or connect to an ESP32 to see shared vehicles.</p>
      </div>
    {% endif %}
  </div>

  {# Connected vehicles are integrated into the main vehicle list above with badges #}
</div>

<script>
let sensorData = new Map();
let websocket = null;
let isOnline = navigator.onLine;

function detectModeAndConnect() {
  // Try ESP32 first (AP mode)
  testESP32Connection()
    .then(available => {
      if (available) {
        connectToESP32();
      } else if (isOnline) {
        // Online mode - could scan for ESP32s on network here
        updateStatus('online');
      } else {
        updateStatus('offline');
      }
    });
}

async function testESP32Connection() {
  try {
    const response = await fetch('http://192.168.4.1/status', { 
      method: 'GET',
      signal: AbortSignal.timeout(2000) // 2 second timeout
    });
    return response.ok;
  } catch {
    return false;
  }
}

function connectToESP32() {
  updateStatus('ap');
  
  // Connect WebSocket
  websocket = new WebSocket('ws://192.168.4.1/ws');
  
  websocket.onopen = () => {
    console.log('Connected to ESP32');
    updateStatus('connected');
  };
  
  websocket.onmessage = (event) => {
    const data = JSON.parse(event.data);
    sensorData.set(data.mac_address, data);
    updateTable();
  };
  
  websocket.onclose = () => {
    console.log('ESP32 disconnected');
    updateStatus('disconnected');
    // Retry connection
    setTimeout(connectToESP32, 3000);
  };
}

function connectToDevice(macAddress) {
  // This function will be called when user clicks "Connect" on a registered device
  // You can implement specific connection logic for known devices here
  console.log('Attempting to connect to device:', macAddress);
  
  // For now, just try the standard ESP32 connection
  detectModeAndConnect();
}

function updateStatus(mode = 'loading') {
  const statusBar = document.getElementById('status-bar');
  const statusText = document.getElementById('status-text');
  
  switch(mode) {
    case 'connected':
      statusBar.className = 'bg-green-600 p-3 rounded mb-6';
      statusText.textContent = '✅ Connected to ESP32';
      break;
    case 'ap':
      statusBar.className = 'bg-yellow-600 p-3 rounded mb-6';
      statusText.textContent = '📡 AP Mode - Connecting...';
      break;
    case 'online':
      statusBar.className = 'bg-blue-600 p-3 rounded mb-6';
      statusText.textContent = '🌐 Online Mode';
      break;
    case 'offline':
      statusBar.className = 'bg-red-600 p-3 rounded mb-6';
      statusText.textContent = '📴 Offline';
      break;
    case 'disconnected':
      statusBar.className = 'bg-red-600 p-3 rounded mb-6';
      statusText.textContent = '❌ Disconnected - Retrying...';
      break;
    default:
      statusBar.className = 'bg-gray-700 p-3 rounded mb-6';
      statusText.textContent = '⏳ Loading...';
  }
}

function updateTable() {
  const tbody = document.getElementById('sensor-data');
  const totalWeight = document.getElementById('total-weight');
  const deviceCount = document.getElementById('device-count');
  
  if (sensorData.size === 0) return;
  
  let html = '';
  let total = 0;
  
  sensorData.forEach((data, mac) => {
    const weight = parseFloat(data.weight) || 0;
    total += weight;
    
    html += `
      <tr style="border-bottom: 1px solid #374151;">
        <td style="padding: 15px; color: #e2e8f0;">${data.device_name || mac.slice(-4)}</td>
        <td style="padding: 15px; text-align: right; color: #f1f5f9; font-weight: bold;">${weight.toFixed(1)}</td>
        <td style="padding: 15px; text-align: right; color: #e2e8f0;">${data.main_air_pressure}</td>
        <td style="padding: 15px; text-align: right; color: #e2e8f0;">${data.temperature}</td>
        <td style="padding: 15px; color: #22c55e;">● Online</td>
      </tr>
    `;
  });
  
  tbody.innerHTML = html;
  totalWeight.textContent = `${total.toFixed(1)} lbs`;
  deviceCount.textContent = sensorData.size;
}

// Vehicle drag and drop functionality
function initVehicleSorting() {
  const vehicleList = document.getElementById('vehicle-list');
  if (!vehicleList) return;

  let draggedElement = null;

  vehicleList.addEventListener('dragstart', (e) => {
    if (e.target.classList.contains('drag-handle') || e.target.closest('.drag-handle')) {
      draggedElement = e.target.closest('[data-vehicle-id]');
      draggedElement.style.opacity = '0.5';
    }
  });

  vehicleList.addEventListener('dragend', (e) => {
    if (draggedElement) {
      draggedElement.style.opacity = '';
      draggedElement = null;
    }
  });

  vehicleList.addEventListener('dragover', (e) => {
    e.preventDefault();
  });

  vehicleList.addEventListener('drop', (e) => {
    e.preventDefault();
    if (!draggedElement) return;

    const target = e.target.closest('[data-vehicle-id]');
    if (target && target !== draggedElement) {
      const rect = target.getBoundingClientRect();
      const midpoint = rect.top + rect.height / 2;
      
      if (e.clientY < midpoint) {
        target.parentNode.insertBefore(draggedElement, target);
      } else {
        target.parentNode.insertBefore(draggedElement, target.nextSibling);
      }
      
      saveVehicleOrder();
    }
  });

  // Make drag handles draggable
  document.querySelectorAll('.drag-handle').forEach(handle => {
    handle.draggable = true;
  });
}

function saveVehicleOrder() {
  const vehicleElements = document.querySelectorAll('[data-vehicle-id]');
  const order = Array.from(vehicleElements).map(el => parseInt(el.dataset.vehicleId));
  
  fetch('{{ path('vehicle_sort_user') }}', {
    method: 'POST',
    headers: {
      'Content-Type': 'application/json',
    },
    body: JSON.stringify({ order: order })
  });
}

// Initialize everything when page loads
document.addEventListener('DOMContentLoaded', () => {
  detectModeAndConnect();
  updateStatus();
  initVehicleSorting();
  startLiveDataPolling(); // New: Start polling for live data
  
  // Listen for network changes
  window.addEventListener('online', () => {
    isOnline = true;
    detectModeAndConnect();
    startLiveDataPolling(); // Restart polling when back online
  });
  
  window.addEventListener('offline', () => {
    isOnline = false;
    updateStatus();
    stopLiveDataPolling(); // Stop polling when offline
  });
});

// Live data polling variables
let liveDataInterval = null;

function startLiveDataPolling() {
  // Clear any existing interval
  stopLiveDataPolling();
  
  // Start polling every 30 seconds
  liveDataInterval = setInterval(fetchLiveData, 30000);
  
  // Fetch immediately on start
  fetchLiveData();
}

function stopLiveDataPolling() {
  if (liveDataInterval) {
    clearInterval(liveDataInterval);
    liveDataInterval = null;
  }
}

function fetchLiveData() {
  fetch('/calibration/api/devices/live-data')
    .then(response => {
      if (!response.ok) {
        throw new Error('Failed to fetch live data');
      }
      return response.json();
    })
    .then(data => {
      updateLiveTable(data);
      updateStatus('connected'); // Show we're getting live data
    })
    .catch(error => {
      console.error('Error fetching live data:', error);
      updateStatus('offline');
    });
}

function updateLiveTable(data) {
  const tbody = document.getElementById('sensor-data');
  const totalWeight = document.getElementById('total-weight');
  const deviceCount = document.getElementById('device-count');
  
  if (!data.devices || data.devices.length === 0) {
    tbody.innerHTML = '<tr><td colspan="5" class="p-6 text-center text-gray-400">📡 No devices with recent data...</td></tr>';
    totalWeight.textContent = '0.0 lbs';
    deviceCount.textContent = '0';
    return;
  }
  
  let html = '';
  
  data.devices.forEach(device => {
    const weight = parseFloat(device.weight) || 0;
    
    // Determine status color based on last_seen
    let statusColor = '#ef4444'; // Default red for old data
    let statusText = `● ${device.last_seen}`;
    
    if (device.last_seen === 'online') {
      statusColor = '#22c55e'; // Green for online
      statusText = '● Online';
    } else if (device.last_seen.includes('minute')) {
      const minutes = parseInt(device.last_seen.match(/\d+/)?.[0] || '999');
      if (minutes <= 10) {
        statusColor = '#22c55e'; // Green for < 10 minutes
      } else if (minutes <= 30) {
        statusColor = '#f59e0b'; // Orange for 10-30 minutes
      }
      statusText = `● ${device.last_seen}`;
    } else if (device.last_seen.includes('hour')) {
      statusColor = '#f59e0b'; // Orange for hours
      statusText = `● ${device.last_seen}`;
    }
    
    html += `
      <tr style="border-bottom: 1px solid #374151;">
        <td style="padding: 15px; color: #e2e8f0;">
          ${device.device_name}
          ${device.vehicle ? '<br><span style="font-size: 12px; color: #9ca3af;">' + device.vehicle + '</span>' : ''}
        </td>
        <td style="padding: 15px; text-align: right; color: #f1f5f9; font-weight: bold;">${weight.toFixed(1)}</td>
        <td style="padding: 15px; text-align: right; color: #e2e8f0;">${device.main_air_pressure}</td>
        <td style="padding: 15px; text-align: right; color: #e2e8f0;">${device.temperature}</td>
        <td style="padding: 15px; color: ${statusColor};">${statusText}</td>
      </tr>
    `;
  });
  
  tbody.innerHTML = html;
  totalWeight.textContent = `${data.total_weight.toFixed(1)} lbs`;
  deviceCount.textContent = data.device_count;
}
</script>
<script>
  // BLE Integration Module - Add this to your dashboard template

// BLE Configuration
const BLE_SERVICE_UUID = '12345678-1234-1234-1234-123456789abc';
const BLE_SENSOR_CHAR_UUID = '87654321-4321-4321-4321-cba987654321';
const BLE_COEFFS_CHAR_UUID = '11111111-2222-3333-4444-555555555555';

// BLE State Management
let bleDevices = new Map(); // Connected BLE devices
let bleDataBuffer = new Map(); // Buffer for 30-second batches
let lastServerSync = 0;
let dbInstance = null;

// Initialize IndexedDB for offline storage
async function initDB() {
    return new Promise((resolve, reject) => {
        const request = indexedDB.open('AirScalesDB', 1);
        
        request.onerror = () => reject(request.error);
        request.onsuccess = () => {
            dbInstance = request.result;
            resolve(dbInstance);
        };
        
        request.onupgradeneeded = (event) => {
            const db = event.target.result;
            
            // Store for sensor data
            if (!db.objectStoreNames.contains('sensorData')) {
                const store = db.createObjectStore('sensorData', { 
                    keyPath: 'id', 
                    autoIncrement: true 
                });
                store.createIndex('mac_address', 'mac_address', { unique: false });
                store.createIndex('timestamp', 'timestamp', { unique: false });
            }
            
            // Store for device info
            if (!db.objectStoreNames.contains('devices')) {
                const deviceStore = db.createObjectStore('devices', { 
                    keyPath: 'mac_address' 
                });
            }
        };
    });
}

// Check if Web Bluetooth is supported
function isBluetoothSupported() {
    return 'bluetooth' in navigator;
}

// Add BLE controls to dashboard
function addBLEControls() {
    // Find the status bar instead
    const statusBar = document.getElementById('status-bar');
    if (!statusBar) return;
    
    // Create BLE controls container
    const bleControls = document.createElement('div');
    bleControls.className = 'bg-gray-800 rounded-lg p-4 mb-6';
    bleControls.innerHTML = `
        <div class="flex items-center justify-between mb-4">
            <h3 class="text-lg font-semibold text-white">📱 Bluetooth Devices</h3>
            <div class="flex space-x-2">
                <button id="scanBLEDevices" 
                        class="px-3 py-1 text-sm font-medium text-blue-400 bg-blue-900 rounded hover:text-blue-200">
                    📡 Scan for Devices
                </button>
                <span id="bleStatus" class="px-3 py-1 text-sm text-gray-400 bg-gray-700 rounded">
                    Ready
                </span>
            </div>
        </div>
        <div id="bleDeviceList" class="space-y-2">
            <p class="text-sm text-gray-400">Click "Scan for Devices" to find nearby AirScales devices</p>
        </div>
    `;
    
    // Insert AFTER the status bar (not before)
    statusBar.parentNode.insertBefore(bleControls, statusBar.nextSibling);
}

// Also, make disconnectBLEDevice globally accessible:
window.disconnectBLEDevice = async function(deviceId) {
    const deviceInfo = bleDevices.get(deviceId);
    if (!deviceInfo) return;
    
    try {
        await deviceInfo.server.disconnect();
    } catch (error) {
        console.error('Disconnect error:', error);
    }
};

// Scan for BLE devices
async function scanForBLEDevices() {
    if (!isBluetoothSupported()) {
        updateBLEStatus('Bluetooth not supported', 'error');
        return;
    }
    
    updateBLEStatus('Scanning...', 'info');
    
    try {
        const device = await navigator.bluetooth.requestDevice({
            filters: [
                { namePrefix: 'AirScales-' }
            ],
            optionalServices: [BLE_SERVICE_UUID]
        });
        
        await connectToBLEDevice(device);
    } catch (error) {
        console.error('BLE scan error:', error);
        updateBLEStatus('Scan failed: ' + error.message, 'error');
    }
}

// Connect to a BLE device
async function connectToBLEDevice(device) {
    try {
        updateBLEStatus(`Connecting to ${device.name}...`, 'info');
        
        const server = await device.gatt.connect();
        const service = await server.getPrimaryService(BLE_SERVICE_UUID);
        const sensorCharacteristic = await service.getCharacteristic(BLE_SENSOR_CHAR_UUID);
        const coeffsCharacteristic = await service.getCharacteristic(BLE_COEFFS_CHAR_UUID);
        
        // Store device info
        const deviceInfo = {
            device,
            server,
            sensorCharacteristic,
            coeffsCharacteristic,
            mac_address: device.name.replace('AirScales-', ''),
            lastSeen: new Date(),
            dataCount: 0
        };
        
        bleDevices.set(device.id, deviceInfo);
        
        // Start notifications
        await sensorCharacteristic.startNotifications();
        sensorCharacteristic.addEventListener('characteristicvaluechanged', 
            (event) => handleBLEData(event, deviceInfo));
        
        // Handle disconnection
        device.addEventListener('gattserverdisconnected', 
            () => handleBLEDisconnection(device));
        
        updateBLEDeviceList();
        updateBLEStatus(`Connected to ${device.name}`, 'success');
        
        console.log('BLE device connected:', device.name);
        
    } catch (error) {
        console.error('BLE connection error:', error);
        updateBLEStatus('Connection failed: ' + error.message, 'error');
    }
}

// Handle incoming BLE data
function handleBLEData(event, deviceInfo) {
    const decoder = new TextDecoder();
    const jsonString = decoder.decode(event.target.value);
    
    try {
        const data = JSON.parse(jsonString);
        console.log('BLE data received:', data);
        
        // Update device info
        deviceInfo.lastSeen = new Date();
        deviceInfo.dataCount++;
        
        // Add to live sensor data (existing dashboard display)
        sensorData.set(data.mac_address, {
            ...data,
            device_name: `BLE: ${deviceInfo.device.name}`,
            source: 'bluetooth'
        });
        
        // Update existing dashboard table
        updateTable();
        
        // Buffer data for server sync
        bufferDataForSync(data);
        
        // Store in IndexedDB
        storeDataInDB(data);
        
        // Update BLE device list
        updateBLEDeviceList();
        
    } catch (error) {
        console.error('Error parsing BLE data:', error);
    }
}

// Buffer data for 30-second server sync
function bufferDataForSync(data) {
    const now = Date.now();
    
    // Send to server every 30 seconds (not every second)
    if (now - lastServerSync > 30000) {
        sendBLEDataToServer(data);
        lastServerSync = now;
    }
}

// Send BLE data to server
async function sendBLEDataToServer(data) {
    try {
        const response = await fetch('/api/esp32/data', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
            },
            body: JSON.stringify({
                ...data,
                source: 'bluetooth_pwa'
            })
        });
        
        if (response.ok) {
            const result = await response.json();
            console.log('BLE data sent to server:', result);
            
            // Check for updated coefficients
            if (result.regression_coefficients) {
                await sendCoefficientsViaBLE(data.mac_address, result.regression_coefficients);
            }
        } else {
            console.error('Server sync failed:', response.status);
        }
    } catch (error) {
        console.error('Server sync error:', error);
    }
}

// Send updated coefficients back to ESP32
async function sendCoefficientsViaBLE(macAddress, coefficients) {
    const deviceInfo = Array.from(bleDevices.values())
        .find(d => d.mac_address === macAddress);
    
    if (!deviceInfo || !deviceInfo.coeffsCharacteristic) return;
    
    try {
        const encoder = new TextEncoder();
        const data = encoder.encode(JSON.stringify(coefficients));
        
        await deviceInfo.coeffsCharacteristic.writeValue(data);
        console.log('Coefficients sent to ESP32:', coefficients);
    } catch (error) {
        console.error('Error sending coefficients:', error);
    }
}

// Store data in IndexedDB
async function storeDataInDB(data) {
    if (!dbInstance) return;
    
    const transaction = dbInstance.transaction(['sensorData'], 'readwrite');
    const store = transaction.objectStore('sensorData');
    
    const record = {
        ...data,
        timestamp: new Date().toISOString(),
        synced: false
    };
    
    await store.add(record);
}

// Handle BLE device disconnection
function handleBLEDisconnection(device) {
    console.log('BLE device disconnected:', device.name);
    
    // Remove from active devices
    bleDevices.delete(device.id);
    
    // Remove from sensor data display
    const deviceInfo = Array.from(sensorData.entries())
        .find(([mac, data]) => data.source === 'bluetooth' && 
               data.device_name.includes(device.name));
    
    if (deviceInfo) {
        sensorData.delete(deviceInfo[0]);
        updateTable();
    }
    
    updateBLEDeviceList();
    updateBLEStatus('Device disconnected', 'warning');
}

// Update BLE status display
function updateBLEStatus(message, type = 'info') {
    const statusElement = document.getElementById('bleStatus');
    if (!statusElement) return;
    
    const colors = {
        info: 'text-blue-400 bg-blue-900',
        success: 'text-green-400 bg-green-900',
        warning: 'text-yellow-400 bg-yellow-900',
        error: 'text-red-400 bg-red-900'
    };
    
    statusElement.className = `text-sm px-3 py-1 rounded ${colors[type] || colors.info}`;
    statusElement.textContent = message;
}

// Update BLE device list display
function updateBLEDeviceList() {
    const listElement = document.getElementById('bleDeviceList');
    if (!listElement) return;
    
    if (bleDevices.size === 0) {
        listElement.innerHTML = '<p class="text-sm text-gray-400">No BLE devices connected</p>';
        return;
    }
    
    let html = '';
    bleDevices.forEach((deviceInfo, deviceId) => {
        const timeSince = Math.floor((Date.now() - deviceInfo.lastSeen.getTime()) / 1000);
        html += `
            <div class="flex items-center justify-between p-3 bg-gray-700 rounded">
                <div class="flex-1">
                    <div class="font-medium text-white">${deviceInfo.device.name}</div>
                    <div class="text-sm text-gray-400">
                        MAC: ${deviceInfo.mac_address} | 
                        Data points: ${deviceInfo.dataCount} |
                        Last seen: ${timeSince}s ago
                    </div>
                </div>
                <div class="flex space-x-2">
                    <span class="px-2 py-1 text-xs text-green-400 bg-green-900 rounded">Connected</span>
                    <button onclick="disconnectBLEDevice('${deviceId}')" 
                            class="px-2 py-1 text-xs text-red-400 bg-red-900 rounded hover:text-red-200">
                        Disconnect
                    </button>
                </div>
            </div>
        `;
    });
    
    listElement.innerHTML = html;
}

// Disconnect BLE device
async function disconnectBLEDevice(deviceId) {
    const deviceInfo = bleDevices.get(deviceId);
    if (!deviceInfo) return;
    
    try {
        await deviceInfo.server.disconnect();
    } catch (error) {
        console.error('Disconnect error:', error);
    }
}

// Initialize BLE integration
async function initBLEIntegration() {
    if (!isBluetoothSupported()) {
        console.log('Web Bluetooth not supported');
        return;
    }
    
    // Initialize IndexedDB
    await initDB();
    
    // Add BLE controls to dashboard
    addBLEControls();
    
    // Bind scan button
    const scanButton = document.getElementById('scanBLEDevices');
    if (scanButton) {
        scanButton.addEventListener('click', scanForBLEDevices);
    }
    
    console.log('BLE integration initialized');
}

// Extend your existing DOMContentLoaded event
document.addEventListener('DOMContentLoaded', () => {
    // Your existing initialization code...
    detectModeAndConnect();
    updateStatus();
    initVehicleSorting();
    startLiveDataPolling();
    
    // ADD THIS: Initialize BLE integration
    initBLEIntegration();
    
    // Your existing event listeners...
    window.addEventListener('online', () => {
        isOnline = true;
        detectModeAndConnect();
        startLiveDataPolling();
    });
    
    window.addEventListener('offline', () => {
        isOnline = false;
        updateStatus();
        stopLiveDataPolling();
    });
});
</script>
{% endblock %}